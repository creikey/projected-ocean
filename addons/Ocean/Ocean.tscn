[gd_scene load_steps=8 format=2]

[ext_resource path="res://addons/Ocean/noise_tileable.png" type="Texture" id=1]
[ext_resource path="res://addons/Ocean/Ocean.gd" type="Script" id=2]
[ext_resource path="res://addons/Ocean/CubeCamera.tscn" type="PackedScene" id=3]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode skip_vertex_transform, cull_front, unshaded;

uniform sampler2D waves;

uniform float alpha = 0.9;

uniform sampler2D noise;
uniform vec4 noise_params;
/*This uniform contains data that changes noise.
X- The amplitude of the noise.
Y- The frequency of the noise.
Z- The propagation speed of the noise.
W- Whether to use noise. Values greater than 0 means yes.
*/

uniform samplerCube environment;
uniform vec4 water_color: hint_color;

uniform float project_bias = 1.2;

uniform float time_offset;

mat3 getRotation(mat4 camera) {
	return mat3(
		camera[0].xyz,
		camera[1].xyz,
		camera[2].xyz
	);}
vec3 getPosition(mat4 camera) {
	return -camera[3].xyz * getRotation(camera);}

vec2 getImagePlan(mat4 projection, vec2 uv) {
	float focal = projection[0].x * project_bias;
	float aspect = projection[1].y * project_bias;
	
	return vec2((uv.x - 0.5) * aspect, (uv.y - 0.5) * focal);}
vec3 getCamRay(mat4 projection, mat3 rotation, vec2 screenUV) {
	return vec3(screenUV.xy, projection[0].x) * rotation;}
vec3 interceptPlane(vec3 source, vec3 dir, vec4 plane) {
	float dist = (-plane.w - dot(plane.xyz, source)) / dot(plane.xyz, dir);
	if(dist < 0.0) {
		return source + dir * dist;
	} else {
		return -(vec3(source.x, plane.w, source.z) + vec3(dir.x, plane.w, dir.z) * 100000.0);
	}}

vec3 computeProjectedPosition(in vec3 cam_pos, in mat3 cam_rot, in mat4 projection, in vec2 uv) {
	vec2 screenUV = getImagePlan(projection, uv);
	
	vec3 ray = getCamRay(projection, cam_rot, screenUV);
	return interceptPlane(cam_pos, ray, vec4(0.0,-1.0,0.0,0.0));
}

float noise3D(vec3 p) {
	float iz = floor(p.z);
	float fz = fract(p.z);
	vec2 a_off = vec2(0.852, 29.0) * iz*0.643;
	vec2 b_off = vec2(0.852, 29.0) * (iz+1.0)*0.643;
	float a = texture(noise, p.xy + a_off).r;
	float b = texture(noise, p.xy + b_off).r;
	
	return mix(a, b, fz);
}

vec3 wave(vec2 pos, float time) {
	vec3 new_p = vec3(pos.x, 0.0, pos.y);
	
	float w, amp, steep, phase;
	vec2 dir;
	for(int i = 0; i < textureSize(waves, 0).y; i++) {
		amp = texelFetch(waves, ivec2(0, i), 0).r;
		if(amp == 0.0) continue;
		
		dir = vec2(texelFetch(waves, ivec2(2, i), 0).r, texelFetch(waves, ivec2(3, i), 0).r);
		w = texelFetch(waves, ivec2(4, i), 0).r;
		steep = texelFetch(waves, ivec2(1, i), 0).r /(w*amp);
		phase = 2.0 * w;
		
		float W = dot(w*dir, pos) + phase*time;
		
		new_p.xz += steep*amp * dir * cos(W);
		new_p.y += amp * sin(W);
	}
	if(noise_params.w > 0.0)
		new_p.y += noise3D(vec3(pos.xy*noise_params.y, time*noise_params.z))*noise_params.x;
	return new_p;
}

vec3 wave_normal(vec2 pos, float time, float res) {
	
	vec3 right = wave(pos + vec2(res, 0.0), time);
	vec3 left = wave(pos - vec2(res, 0.0), time);
	vec3 down = wave(pos - vec2(0.0, res), time);
	vec3 up = wave(pos + vec2(0.0, res), time);
	
	return -normalize(cross(right-left, down-up));
}

varying vec2 vert_coord;
varying float vert_dist;

varying vec3 eyeVector;

void vertex() {
	vec2 screen_uv = VERTEX.xz + 0.5;
	
	mat4 projected_cam_matrix = INV_CAMERA_MATRIX;
	
	mat3 camRotation = getRotation(projected_cam_matrix);
	vec3 camPosition = getPosition(projected_cam_matrix);
	
	VERTEX = computeProjectedPosition(camPosition, camRotation, PROJECTION_MATRIX, screen_uv);
	
	vec2 pre_displace = VERTEX.xz;
	VERTEX = wave(VERTEX.xz, time_offset);
	if( any(lessThan(screen_uv, vec2(0.0))) || any(greaterThan(screen_uv, vec2(1.0))) )
		VERTEX.xz = pre_displace;
	
	eyeVector = normalize(VERTEX - camPosition);
	vert_coord = VERTEX.xz;
	VERTEX = (INV_CAMERA_MATRIX * vec4(VERTEX, 1.0)).xyz;
	vert_dist = length(VERTEX);
}

float fresnel(float n1, float n2, float cos_theta) {
	float R0 = pow((n1 - n2) / (n1+n2), 2);
	return R0 + (1.0 - R0)*pow(1.0 - cos_theta, 5);
}

void fragment() {
	NORMAL = wave_normal(vert_coord, time_offset, vert_dist/40.0);
	NORMAL = mix(NORMAL, vec3(0, -1, 0), min(vert_dist/1000.0, 1));
	
	float eye_dot_norm = dot(eyeVector, NORMAL);
	float n1 = 1.0, n2 = 1.3333;
	
	float reflectiveness = fresnel(n1, n2, abs(eye_dot_norm));
	
	vec3 reflect_global = texture(environment, reflect(eyeVector, NORMAL)).rgb;
	vec3 refract_global;
	if(eye_dot_norm < 0.0)
		refract_global = texture(environment, refract(eyeVector, NORMAL, n1/n2)).rgb;
	else
		refract_global = water_color.rgb;
	
	ALBEDO = mix(refract_global, reflect_global, reflectiveness);
	ALPHA = alpha;
}"

[sub_resource type="Image" id=5]
data = {
"data": PoolByteArray( 246, 40, 220, 61, 237, 158, 188, 61, 20, 166, 192, 190, 165, 126, 174, 63, 193, 40, 149, 61, 81, 107, 26, 61, 246, 40, 28, 62, 208, 162, 42, 63, 249, 166, 159, 63, 39, 225, 217, 61, 20, 29, 73, 62, 0, 0, 0, 0, 188, 31, 248, 62, 44, 15, 170, 63, 117, 204, 59, 62, 125, 29, 120, 62, 42, 169, 19, 62, 253, 255, 127, 191, 1, 0, 128, 191, 105, 2, 35, 62, 4, 231, 76, 62, 0, 0, 0, 0, 255, 241, 77, 191, 191, 224, 148, 63, 49, 213, 203, 61, 192, 91, 160, 62, 0, 0, 0, 0, 161, 109, 186, 190, 160, 234, 174, 63, 246, 109, 227, 61, 0, 0, 192, 63, 0, 0, 0, 0, 144, 166, 57, 63, 75, 104, 155, 63, 253, 173, 0, 61, 84, 193, 104, 63, 20, 63, 198, 61, 53, 182, 230, 190, 164, 149, 171, 63, 136, 12, 38, 61, 49, 153, 62, 64, 29, 167, 232, 60, 34, 3, 32, 191, 22, 97, 162, 63, 253, 173, 128, 60, 115, 104, 65, 63, 170, 207, 85, 62, 253, 255, 127, 63, 1, 0, 128, 191, 253, 173, 128, 61, 160, 248, 113, 62, 0, 0, 0, 0, 146, 60, 176, 191, 245, 87, 165, 62, 10, 85, 235, 61 ),
"format": "RFloat",
"height": 11,
"mipmaps": false,
"width": 5
}

[sub_resource type="ImageTexture" id=6]
flags = 0
flags = 0
image = SubResource( 5 )
size = Vector2( 5, 11 )

[sub_resource type="ShaderMaterial" id=4]
shader = SubResource( 1 )
shader_param/alpha = 0.9
shader_param/noise_params = Plane( -1.054, 0.065, 0.3, 1 )
shader_param/water_color = Color( 0.129412, 0.239216, 0.321569, 1 )
shader_param/project_bias = 1.601
shader_param/time_offset = 25799.2
shader_param/waves = SubResource( 6 )
shader_param/noise = ExtResource( 1 )

[node name="Ocean" type="ImmediateGeometry"]
material_override = SubResource( 4 )
script = ExtResource( 2 )
waves = [ Vector3( 10.75, 9.21, 86.27 ), Vector3( 3.77, 15.25, 59.06 ), Vector3( 19.64, 0, 34.26 ), Vector3( 24.23, 14.42, 39.47 ), Vector3( 20.01, 0, 63.13 ), Vector3( 31.32, 0, 56.58 ), Vector3( 150, 0, 200 ), Vector3( 90.92, 9.68, 154.99 ), Vector3( 297.81, 2.84, 400 ), Vector3( 75.55, 20.88, 100 ), Vector3( 23.63, 0, 54.68 ) ]
wave_directions = PoolRealArray( 60.43, 16.88, 24.96, 180, 79.67, 59.92, 14.15, 63.58, 71.23, 270, 121.8 )
speed = 4.54
noise_amplitude = -1.054
noise_speed = 0.3
seed_value = 14
cube_cam_path = NodePath("EnvironmentCameras")

[node name="EnvironmentCameras" parent="." instance=ExtResource( 3 )]
